import itertools as it
import json
from matplotlib import pyplot as plt
import numpy as np
from typing import Callable


def load_data(data_path, class_labels_path, debug=False):
    """
    Loads the raw input data. Returns the tuple (samples, labels) for the training, validation and test
    subsets, plus a dictionary containing data properties.
    Input Parameters:
      - data_path: Path of the data file. It must contains the train-val-test splits of the dataset in the
                   following order: {train_x,val_x,test_x,train_y,val_y,test_y}.
                   Each sample must represent a time series and have this shape: [samples, timesteps, dims].
      - class_labels_path: Path of the class labels JSON file. It must contain the ordered list of class samples.
    """
    class_labels = None
    with open(class_labels_path, "r") as f:
        class_labels = json.load(f)

    data = None
    with open(data_path, "rb") as f:
        data = np.load(f, allow_pickle=True)

        train_x, train_y = data["arr_0"], data["arr_3"]
        val_x, val_y = data["arr_1"], data["arr_4"]
        test_x, test_y = data["arr_2"], data["arr_5"]

        n_classes = len(np.unique(np.argmax(train_y, axis=1)))
        assert n_classes == len(class_labels)

        data_prop = {
            "n_timesteps": train_x.shape[1],
            "n_dims": train_x.shape[2],
            "class_labels": class_labels,
            "n_classes": n_classes,
        }

        if debug:
            print(f"n_samples_train: {train_x.shape[0]}")
            print(f"n_samples_val: {val_x.shape[0]}")
            print(f"n_samples_test: {test_x.shape[0]}")

    return train_x, train_y, val_x, val_y, test_x, test_y, data_prop


def filter_data_by_class(x, y, c):
    """
    Returns only samples associated with the class c.
    Input Parameters:
      - x: Data samples
      - y: Labels, must correspond with the samples
      - c: An integer selecting the class, must be in the interval 0-17
    """
    return x[np.argmax(y, axis=1) == c]


def calc_distance_matrix(
    distance_fn: Callable[[int, int, int], float], data_prop, display_matrix=False
):
    """
    Calculates the distance matrix between all the pairs of classes.
    Returns the distance matrix and a dictionary containing all the distances for each pair of classes.
    Input Parameters:
      - distance_fn: A function that will be used to calculate the cross-class distance
      - data_prop: A dict containing properties of the data. Generated by the load_data method
      - display_matric: A boolean that controls if the distance matrix must be displayed
    """
    matrix = np.zeros((data_prop["n_classes"], data_prop["n_classes"]))
    values = []
    for c1 in range(data_prop["n_classes"]):
        for c2 in range(data_prop["n_classes"]):
            val = distance_fn(c1, c2)
            matrix[c1][c2] = val
            if c1 <= c2:
                values.append((c1, c2, np.round(val, decimals=3)))

    if display_matrix:
        plt.figure(figsize=(6, 6))
        plt.matshow(matrix, fignum=1, cmap="hot")
        plt.colorbar()
        plt.show()

    return matrix, {(v[0], v[1]): v[2] for v in values}


def search_class_combinations(
    data_prop, pairs_distances_dict, comb_size, best_first=True
):
    """
    Search for the most or less separable combinations of n classes
    Input Parameters:
      - data_prop: A dict containing properties of the data. Generated by the load_data method
      - pairs_distances_dict: List containing all the distance value for each pair of class in the dataset
      - comb_size: Controls the size of the class combinations to search for
      - best_first: Controls the order of the output (True: most separable combinations first)
    """
    combs = list(it.combinations(range(data_prop["n_classes"]), comb_size))
    result = []

    for comb in combs:
        sum = 0
        # Sum all the distances values for every pair of classes in comb
        for pair in list(it.combinations(comb, 2)):
            sum += pairs_distances_dict[pair]
        result.append(([data_prop["class_labels"][i] for i in comb], sum))

    return sorted(result, key=lambda x: x[1], reverse=best_first)
